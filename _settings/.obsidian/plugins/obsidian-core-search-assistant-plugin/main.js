/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => CoreSearchAssistantPlugin2
});

// src/Events.ts
var import_obsidian = __toModule(require("obsidian"));
var EVENT_SEARCH_RESULT_ITEM_DETECTED = "search-result-item-detected";
var EVENT_SORT_ORDER_CHANGED = "sort-order-changed";
var CoreSearchAssistantEvents = class extends import_obsidian.Events {
  trigger(name, ...data) {
    super.trigger(name, ...data);
  }
  on(name, callback, ctx) {
    return super.on(name, callback, ctx);
  }
};

// src/Controller.ts
var obsidian = __toModule(require("obsidian"));

// src/components/OptionModal.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/types/Option.ts
var searchOptions = {
  matchingCase: {
    iconId: "uppercase-lowercase-a",
    description: "Toggle matching case"
  },
  explainSearch: {
    iconId: "info",
    description: "Toggle explanation of search term"
  },
  collapseAll: {
    iconId: "bullet-list",
    description: "Toggle collapsing results"
  },
  extraContext: {
    iconId: "expand-vertically",
    description: "Toggle showing more context"
  },
  alphabetical: {
    iconId: "down-arrow-with-tail",
    description: "Sort by file name (A \u2192 Z)"
  },
  alphabeticalReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by file name (Z \u2192 A)"
  },
  byModifiedTime: {
    iconId: "down-arrow-with-tail",
    description: "Sort by modified time (new \u2192 old)"
  },
  byModifiedTimeReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by modified time (old \u2192 new)"
  },
  byCreatedTime: {
    iconId: "down-arrow-with-tail",
    description: "Sort by created time (new \u2192 old)"
  },
  byCreatedTimeReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by created time (old \u2192 new)"
  }
};

// src/components/OptionModal.ts
var OptionModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, modeScope) {
    super(app);
    this.plugin = plugin;
    this.modeScope = modeScope;
    this.items = [
      {
        id: "matchingCase",
        key: "a",
        onChoose: () => {
          var _a, _b, _c;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleMatchingCase();
          (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
          (_c = this.plugin.controller) == null ? void 0 : _c.reset();
        }
      },
      {
        id: "explainSearch",
        key: "s",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleExplainSearch();
        }
      },
      {
        id: "collapseAll",
        key: "d",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleCollapseAll();
        }
      },
      {
        id: "extraContext",
        key: "f",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleExtraContext();
        }
      },
      {
        id: "alphabetical",
        key: "g",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("alphabetical");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "alphabeticalReverse",
        key: "h",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("alphabeticalReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byModifiedTime",
        key: "j",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byModifiedTime");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byModifiedTimeReverse",
        key: "k",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byModifiedTimeReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byCreatedTime",
        key: "l",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byCreatedTime");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byCreatedTimeReverse",
        key: ";",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byCreatedTimeReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      }
    ];
  }
  onOpen() {
    this.modeScope.push();
    this.items.forEach((item) => {
      this.scope.register([], item.key, item.onChoose);
    });
    this.renderOptions();
  }
  onClose() {
    const { containerEl } = this;
    containerEl.empty();
    setTimeout(() => this.modeScope.pop(), 100);
  }
  renderOptions() {
    const { contentEl } = this;
    contentEl.empty();
    this.containerEl.addClass("core-search-assistant_option-modal");
    this.items.forEach((item) => {
      const entryEl = contentEl.createEl("div", {
        cls: "suggestion-item"
      });
      const iconEl = entryEl.createEl("span", {
        cls: "suggestion-icon"
      });
      (0, import_obsidian2.setIcon)(iconEl, searchOptions[item.id].iconId);
      entryEl.createEl("span", {
        text: searchOptions[item.id].description,
        cls: "suggestion-content"
      });
      entryEl.createEl("kbd", {
        text: item.key.toUpperCase(),
        cls: "suggestion-hotkey"
      });
    });
  }
};

// src/Setting.ts
var import_obsidian7 = __toModule(require("obsidian"));

// src/ui/HotkeySetter.ts
var import_obsidian6 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/HotkeyEntry.svelte
var import_obsidian5 = __toModule(require("obsidian"));

// src/ui/HotkeySetting.svelte
var import_obsidian4 = __toModule(require("obsidian"));

// src/utils/Keymap.ts
var import_obsidian3 = __toModule(require("obsidian"));
var CODE_KEY_MAP = {
  Semicolon: ";",
  Quote: "'",
  Comma: ",",
  Period: ".",
  Slash: "/",
  BracketLeft: "[",
  BracketRight: "]",
  BackSlash: "\\",
  Backquote: "`",
  Space: " ",
  Minus: "-",
  Equal: "="
};
for (let i = 0; i < 10; i++) {
  CODE_KEY_MAP[`Digit${i}`] = i.toString();
}
for (let i = 65; i < 91; i++) {
  const char = String.fromCharCode(i);
  const upChar = char.toUpperCase();
  CODE_KEY_MAP[`Key${upChar}`] = char;
}
function convertCodeToKey(code) {
  var _a;
  return (_a = CODE_KEY_MAP[code]) != null ? _a : code;
}
function convertKeyToText(key) {
  switch (key) {
    case "ArrowLeft":
      return "\u2190";
    case "ArrowRight":
      return "\u2192";
    case "ArrowUp":
      return "\u2191";
    case "ArrowDown":
      return "\u2193";
    case "Mod":
      return import_obsidian3.Platform.isMacOS ? "\u2318" : "Ctrl";
    case "Ctrl":
      return import_obsidian3.Platform.isMacOS ? "\u2303" : "Ctrl";
    case "Meta":
      return import_obsidian3.Platform.isMacOS ? "\u2318" : "Win";
    case "Alt":
      return import_obsidian3.Platform.isMacOS ? "\u2325" : "Alt";
    case "Shift":
      return import_obsidian3.Platform.isMacOS ? "\u21E7" : "Shift";
    case " ":
      return "Space";
    case "Enter":
      return "\u21B5";
    default:
      return key.charAt(0).toUpperCase() + key.slice(1);
  }
}
function convertHotkeyToText(hotkey) {
  const parts = [];
  hotkey.modifiers.forEach((mod) => {
    parts.push(convertKeyToText(mod));
  });
  const modifierPart = parts.join(" ");
  const keyPart = convertKeyToText(hotkey.key);
  return ` ${modifierPart} ${keyPart} `;
}
function compileModifiers(modifiers) {
  return modifiers.map((modifier) => {
    return modifier === "Mod" ? import_obsidian3.Platform.isMacOS ? "Meta" : "Ctrl" : modifier;
  }).sort().join(",");
}
function decompileModifiers(modifiersId) {
  const modifiers = [];
  const parts = modifiersId.split(",");
  parts.forEach((s) => {
    if (import_obsidian3.Platform.isMacOS && s === "Meta" || !import_obsidian3.Platform.isMacOS && s === "Ctrl") {
      modifiers.push("Mod");
      return;
    }
    if (s === "Alt" || s === "Shift" || s === "Meta" || s === "Ctrl") {
      modifiers.push(s);
      return;
    }
  });
  return modifiers;
}
function getModifiers(evt) {
  const modifiers = [];
  evt.ctrlKey && modifiers.push("Ctrl");
  evt.metaKey && modifiers.push("Meta");
  evt.altKey && modifiers.push("Alt");
  evt.shiftKey && modifiers.push("Shift");
  return compileModifiers(modifiers);
}
function getHotkey(evt) {
  const modifiers = decompileModifiers(getModifiers(evt));
  const key = convertCodeToKey(evt.code);
  return {
    modifiers,
    key
  };
}
function contain(hotkeys, hotkey) {
  const hotkeyId = convertHotkeyToText(hotkey);
  return hotkeys.some((key) => {
    return hotkeyId === convertHotkeyToText(key);
  });
}

// src/ui/HotkeySetting.svelte
function add_css(target) {
  append_styles(target, "svelte-2wacg2", ".icon-container.svelte-2wacg2{display:inline-block;cursor:pointer;width:16px;height:16px;border-radius:10px;line-height:16px;text-align:center}.icon-container.svelte-2wacg2:hover{background-color:var(--background-modifier-error);color:var(--text-on-accent)}.setting-hotkey.svelte-2wacg2{font-size:12px;background-color:var(--background-secondary-alt);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative}");
}
function create_fragment(ctx) {
  let span1;
  let t0_value = convertHotkeyToText(ctx[0]) + "";
  let t0;
  let t1;
  let span0;
  let mounted;
  let dispose;
  return {
    c() {
      span1 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span0 = element("span");
      attr(span0, "class", "icon-container svelte-2wacg2");
      attr(span1, "class", "setting-hotkey svelte-2wacg2");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t0);
      append(span1, t1);
      append(span1, span0);
      ctx[3](span0);
      if (!mounted) {
        dispose = listen(span0, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = convertHotkeyToText(ctx2[0]) + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let iconContainerEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (iconContainerEl instanceof HTMLSpanElement) {
      (0, import_obsidian4.setIcon)(iconContainerEl, "cross", 8);
    }
  });
  function onIconClicked() {
    dispatcher("removed");
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconContainerEl = $$value;
      $$invalidate(1, iconContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
  };
  return [hotkey, iconContainerEl, onIconClicked, span0_binding];
}
var HotkeySetting = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { hotkey: 0 }, add_css);
  }
};
var HotkeySetting_default = HotkeySetting;

// src/ui/HotkeyEntry.svelte
function add_css2(target) {
  append_styles(target, "svelte-1my40ui", ".item-container.svelte-1my40ui{display:flex;align-items:center;padding:18px 0 18px 0;border-top:1px solid var(--background-modifier-border)}.info-container.svelte-1my40ui{flex:1 1 auto;flex-grow:1;margin-right:20px}.control-container.svelte-1my40ui{flex:1 1 auto;text-align:right;display:flex;justify-content:flex-end;align-items:center}.hotkeys-container.svelte-1my40ui{display:flex;flex-direction:column;margin-right:6px}.setting-hotkey.svelte-1my40ui{font-size:12px;background-color:var(--interactive-accent);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative;color:var(--text-on-accent)}.icon-container.svelte-1my40ui{padding:4px 6px;border-radius:4px;color:var(--text-faint);cursor:pointer;height:26px}.icon-container.svelte-1my40ui:hover{background-color:var(--background-secondary-alt);color:var(--text-normal)}.icon-container.svelte-1my40ui .clickable-icon{color:unset;cursor:unset;margin:unset}.icon-container.svelte-1my40ui .setting-editor-extra-setting-button{line-height:0}.icon-container.svelte-1my40ui .clickable-icon svg{position:relative;bottom:2px}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let hotkeysetting;
  let current;
  function removed_handler() {
    return ctx[8](ctx[13]);
  }
  hotkeysetting = new HotkeySetting_default({ props: { hotkey: ctx[13] } });
  hotkeysetting.$on("removed", removed_handler);
  return {
    c() {
      create_component(hotkeysetting.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeysetting, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkeysetting_changes = {};
      if (dirty & 16)
        hotkeysetting_changes.hotkey = ctx[13];
      hotkeysetting.$set(hotkeysetting_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkeysetting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeysetting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeysetting, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Press hotkey...";
      attr(div, "class", "setting-hotkey svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment2(ctx) {
  var _a;
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let t3;
  let span0;
  let t4;
  let span1;
  let current;
  let mounted;
  let dispose;
  let each_value = (_a = ctx[4]) != null ? _a : [];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      span0 = element("span");
      t4 = space();
      span1 = element("span");
      attr(div0, "class", "info-container svelte-1my40ui");
      attr(div1, "class", "hotkeys-container svelte-1my40ui");
      attr(span0, "class", "icon-container svelte-1my40ui");
      attr(span1, "class", "icon-container svelte-1my40ui");
      attr(div2, "class", "control-container svelte-1my40ui");
      attr(div3, "class", "item-container svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      append(div2, t3);
      append(div2, span0);
      ctx[9](span0);
      append(div2, t4);
      append(div2, span1);
      ctx[11](span1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[10]),
          listen(span1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 48) {
        each_value = (_a2 = ctx2[4]) != null ? _a2 : [];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      ctx[9](null);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var ICON_SIZE = 22;
function instance2($$self, $$props, $$invalidate) {
  let _hotkeys;
  let _listening;
  let { actionName } = $$props;
  let { hotkeys } = $$props;
  let { listening = false } = $$props;
  let restoreButtonEl;
  let addHotkeyButtonEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (restoreButtonEl) {
      const component = new import_obsidian5.ExtraButtonComponent(restoreButtonEl).setTooltip("Restore default");
      (0, import_obsidian5.setIcon)(component.extraSettingsEl, "reset", ICON_SIZE);
    }
    if (addHotkeyButtonEl) {
      const component = new import_obsidian5.ExtraButtonComponent(addHotkeyButtonEl).setTooltip("Customize this action");
      (0, import_obsidian5.setIcon)(component.extraSettingsEl, "any-key", ICON_SIZE);
    }
  });
  const removed_handler = (hotkey) => {
    dispatcher("removed", { removed: hotkey });
  };
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      restoreButtonEl = $$value;
      $$invalidate(1, restoreButtonEl);
    });
  }
  const click_handler = () => {
    dispatcher("restored");
  };
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addHotkeyButtonEl = $$value;
      $$invalidate(2, addHotkeyButtonEl);
    });
  }
  const click_handler_1 = () => {
    dispatcher("start-listening-keys");
  };
  $$self.$$set = ($$props2) => {
    if ("actionName" in $$props2)
      $$invalidate(0, actionName = $$props2.actionName);
    if ("hotkeys" in $$props2)
      $$invalidate(6, hotkeys = $$props2.hotkeys);
    if ("listening" in $$props2)
      $$invalidate(7, listening = $$props2.listening);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(4, _hotkeys = [...hotkeys !== null && hotkeys !== void 0 ? hotkeys : []]);
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, _listening = listening);
    }
  };
  return [
    actionName,
    restoreButtonEl,
    addHotkeyButtonEl,
    _listening,
    _hotkeys,
    dispatcher,
    hotkeys,
    listening,
    removed_handler,
    span0_binding,
    click_handler,
    span1_binding,
    click_handler_1
  ];
}
var HotkeyEntry = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { actionName: 0, hotkeys: 6, listening: 7 }, add_css2);
  }
};
var HotkeyEntry_default = HotkeyEntry;

// src/ui/HotkeySetter.ts
var HotkeySetter = class {
  constructor(app, containerEl, text2, currentHotkeys, defaultHotkeys) {
    this.shouldReflect = (_) => true;
    this.onRestored = () => {
      const { component } = this;
      if (!component)
        return;
      const renewed = [...this.defaultHotkeys];
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onRemoved = (evt) => {
      const { component } = this;
      if (!component)
        return;
      if (!(evt instanceof CustomEvent))
        return;
      const removed = evt.detail.removed;
      const renewed = [...this.currentHotkeys];
      renewed.remove(removed);
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onStartListening = () => {
      const { component } = this;
      if (!component)
        return;
      component.$set({
        listening: true
      });
      this.scope = new import_obsidian6.Scope();
      this.app.keymap.pushScope(this.scope);
      this.scope.register(null, null, (evt) => {
        evt.preventDefault();
        if (evt.key === "Escape") {
          component.$set({
            listening: false
          });
          if (this.scope)
            this.app.keymap.popScope(this.scope);
        }
        const hotkey = getHotkey(evt);
        const collision = contain(this.currentHotkeys, hotkey);
        if (collision)
          return;
        const renewed = [...this.currentHotkeys];
        renewed.push(hotkey);
        if (!this.shouldReflect(renewed, hotkey))
          return;
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
        component.$set({
          listening: false
        });
        if (this.scope)
          this.app.keymap.popScope(this.scope);
      });
    };
    this.app = app;
    this.containerEl = containerEl;
    this.text = text2;
    this.currentHotkeys = [...currentHotkeys];
    this.defaultHotkeys = [...defaultHotkeys];
    this.component = this.attachComponent();
  }
  unload() {
    this.onunload();
  }
  onChanged(cb) {
    this.shouldReflect = cb;
    return this;
  }
  attachComponent() {
    const component = new HotkeyEntry_default({
      target: this.containerEl,
      props: {
        actionName: this.text,
        hotkeys: this.currentHotkeys
      }
    });
    component.$on("removed", this.onRemoved);
    component.$on("restored", this.onRestored);
    component.$on("start-listening-keys", this.onStartListening);
    return component;
  }
  onunload() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
    if (this.scope) {
      this.app.keymap.popScope(this.scope);
    }
  }
};

// src/Setting.ts
var AVAILABLE_OUTLINE_WIDTHS = [0, 3, 5, 7, 10];
var AUTO_PREVIEW_MODE_IDS = ["none", "singleView", "cardView"];
var autoPreviewModeInfos = {
  none: "none",
  singleView: "single view",
  cardView: "card view"
};
var AVAILABLE_CARD_LAYOUT = ["2x2", "2x3", "3x2", "3x3"];
var DEFAULT_SETTINGS = {
  keepSelectedItemsCentered: false,
  outlineWidth: 5,
  autoPreviewMode: "cardView",
  cardViewLayout: "2x3",
  splitDirection: "horizontal",
  autoToggleSidebar: false,
  renderCardsManually: false,
  hideIframe: false,
  searchModeHotkeys: {
    selectNext: [
      { modifiers: ["Ctrl"], key: "n" },
      { modifiers: [], key: "ArrowDown" }
    ],
    selectPrevious: [
      { modifiers: ["Ctrl"], key: "p" },
      { modifiers: [], key: "ArrowUp" }
    ],
    previewModal: [{ modifiers: ["Ctrl"], key: " " }],
    open: [{ modifiers: ["Ctrl"], key: "Enter" }],
    openInNewPane: [{ modifiers: ["Ctrl", "Shift"], key: "Enter" }],
    showOptions: [{ modifiers: ["Shift"], key: " " }],
    nextPage: [{ modifiers: ["Ctrl"], key: "]" }],
    previousPage: [{ modifiers: ["Ctrl"], key: "[" }],
    copyLink: [{ modifiers: ["Ctrl"], key: "i" }]
  },
  previewModalHotkeys: {
    scrollDown: [
      { modifiers: ["Ctrl"], key: "n" },
      { modifiers: [], key: "ArrowDown" }
    ],
    scrollUp: [
      { modifiers: ["Ctrl"], key: "p" },
      { modifiers: [], key: "ArrowUp" }
    ],
    bigScrollDown: [{ modifiers: [], key: " " }],
    bigScrollUp: [{ modifiers: ["Shift"], key: " " }],
    open: [{ modifiers: ["Ctrl"], key: "Enter" }],
    openInNewPage: [{ modifiers: ["Ctrl", "Shift"], key: "Enter" }],
    closeModal: [{ modifiers: ["Ctrl"], key: " " }],
    focusNext: [{ modifiers: [], key: "Tab" }],
    focusPrevious: [{ modifiers: ["Shift"], key: "Tab" }],
    togglePreviewMode: [{ modifiers: ["Ctrl"], key: "e" }],
    copyLink: [{ modifiers: ["Ctrl"], key: "i" }]
  }
};
var CoreSearchAssistantSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.hotkeySetters = [];
  }
  display() {
    this.hide();
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("Keep selected item centered").addToggle((component) => {
      var _a, _b;
      component.setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.keepSelectedItemsCentered) != null ? _b : DEFAULT_SETTINGS.keepSelectedItemsCentered).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        this.plugin.settings.keepSelectedItemsCentered = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Outline width (px)").setDesc("An outline appears when you enter search mode.").addDropdown((component) => {
      var _a;
      AVAILABLE_OUTLINE_WIDTHS.forEach((width) => {
        const text2 = width.toString();
        component.addOption(text2, text2);
      });
      component.setValue(validOutlineWidth((_a = this.plugin.settings) == null ? void 0 : _a.outlineWidth).toString()).onChange((value) => {
        const width = Number.parseInt(value);
        if (!this.plugin.settings) {
          return;
        }
        if (!AVAILABLE_OUTLINE_WIDTHS.includes(width)) {
          return;
        }
        this.plugin.settings.outlineWidth = width;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Auto preview mode").addDropdown((component) => {
      var _a, _b;
      component.addOptions(autoPreviewModeInfos).setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) != null ? _b : "cardView").onChange((id) => {
        if (!this.plugin.settings) {
          return;
        }
        if (!AUTO_PREVIEW_MODE_IDS.includes(id)) {
          return;
        }
        this.plugin.settings.autoPreviewMode = id;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Default layout of card view").addDropdown((component) => {
      var _a, _b;
      AVAILABLE_CARD_LAYOUT.forEach((layout) => {
        component.addOption(layout, layout);
      });
      component.setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.cardViewLayout) != null ? _b : DEFAULT_SETTINGS.cardViewLayout).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        if (!AVAILABLE_CARD_LAYOUT.includes(value)) {
          return;
        }
        this.plugin.settings.cardViewLayout = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Default split direction").setDesc("This applies when you open a file in a new pane").addDropdown((component) => {
      if (!this.plugin.settings) {
        return;
      }
      component.addOptions({
        horizontal: "horizontal",
        vertical: "vertical"
      }).setValue(this.plugin.settings.splitDirection).onChange((direction) => __async(this, null, function* () {
        if (!this.plugin.settings) {
          return;
        }
        if (direction == "horizontal" || direction == "vertical") {
          this.plugin.settings.splitDirection = direction;
          yield this.plugin.saveSettings();
        }
      }));
    });
    new import_obsidian7.Setting(containerEl).setName("Toggle sidebars automatically").setDesc("Automatically collapse the other sidebar when entering the search mode and the search panel when exiting the search mode").addToggle((component) => {
      if (!this.plugin.settings) {
        return;
      }
      component.setValue(this.plugin.settings.autoToggleSidebar).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        this.plugin.settings.autoToggleSidebar = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Render cards manually").setDesc("If enabled, you must hit the enter key to render cards.").addToggle((component) => {
      if (!this.plugin.settings)
        return;
      component.setValue(this.plugin.settings.renderCardsManually).onChange((value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.renderCardsManually = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Hide iframe from auto preview").setDesc("Some iframe elements prevent the keyboard operation.").addToggle((component) => {
      if (!this.plugin.settings) {
        return;
      }
      component.setValue(this.plugin.settings.hideIframe).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        this.plugin.settings.hideIframe = value;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: "Hotkeys" });
    const { settings } = this.plugin;
    containerEl.createEl("h3", { text: "Search mode" });
    if (!settings)
      return;
    SEARCH_MODE_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.searchModeHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.searchModeHotkeys[actionId];
      const description = SEARCH_MODE_HOTKEY_ACTION_INFO[actionId];
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          if (added.modifiers.length === 0)
            return false;
          const collision = Object.values(settings.searchModeHotkeys).some((hotkeys2) => {
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian7.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.searchModeHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
    containerEl.createEl("h3", { text: "Preview Modal" });
    PREVIEW_MODAL_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.previewModalHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.previewModalHotkeys[actionId];
      const description = PREVIEW_MODAL_HOTKEY_ACTION_INFO[actionId];
      DEFAULT_SETTINGS.previewModalHotkeys[actionId];
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          const collision = Object.values(settings.previewModalHotkeys).some((hotkeys2) => {
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian7.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.previewModalHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
  }
  hide() {
    super.hide();
    this.hotkeySetters.forEach((s) => s.unload());
    this.hotkeySetters = [];
  }
};
function validOutlineWidth(width) {
  if (typeof width !== "number") {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  if (!Number.isInteger(width)) {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  if (!AVAILABLE_OUTLINE_WIDTHS.includes(width)) {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  return width;
}
function parseCardLayout(layout) {
  const [row, column] = layout.split("x");
  return [Number.parseInt(row != null ? row : "0"), Number.parseInt(column != null ? column : "0")];
}
var SEARCH_MODE_HOTKEY_ACTION_IDS = [
  "selectNext",
  "selectPrevious",
  "previewModal",
  "open",
  "openInNewPane",
  "showOptions",
  "nextPage",
  "previousPage",
  "copyLink"
];
var SEARCH_MODE_HOTKEY_ACTION_INFO = {
  selectNext: "Select the next item",
  selectPrevious: "Select the previous item",
  previewModal: "Preview the selected item",
  open: "Open the selected item",
  openInNewPane: "Open the selected item in a new pane",
  showOptions: "Set search options",
  nextPage: "Move to the next set of cards",
  previousPage: "Move to the previous set of cards",
  copyLink: "Copy wiki link of the selected item"
};
var PREVIEW_MODAL_HOTKEY_ACTION_IDS = [
  "scrollDown",
  "scrollUp",
  "bigScrollDown",
  "bigScrollUp",
  "open",
  "openInNewPage",
  "closeModal",
  "focusNext",
  "focusPrevious",
  "togglePreviewMode",
  "copyLink"
];
var PREVIEW_MODAL_HOTKEY_ACTION_INFO = {
  scrollDown: "Scroll down a bit",
  scrollUp: "Scroll up a bit",
  bigScrollDown: "Scroll down a lot",
  bigScrollUp: "Scroll up a lot",
  open: "Open the selected item",
  openInNewPage: "Open the selected item in a new pane",
  closeModal: "Close the modal",
  focusNext: "Focus on the next match",
  focusPrevious: "Focus on the previous match",
  togglePreviewMode: "Toggle preview mode",
  copyLink: "Copy wiki link of the selected item"
};

// src/components/PreviewModal.ts
var import_obsidian14 = __toModule(require("obsidian"));

// src/interfaces/ViewGenerator.ts
var import_obsidian8 = __toModule(require("obsidian"));

// src/utils/Util.ts
function delay(millisecond) {
  return __async(this, null, function* () {
    yield new Promise((resolve) => setTimeout(resolve, millisecond));
  });
}
function scrollIteration(editor) {
  const line = lineCount(editor);
  if (line === void 0) {
    return void 0;
  }
  return Math.max(Math.floor(line / 1e3), 1);
}
function lineCount(editor) {
  var _a, _b, _c;
  const line = (_c = (_b = (_a = editor == null ? void 0 : editor["cm"]) == null ? void 0 : _a["state"]) == null ? void 0 : _b["doc"]) == null ? void 0 : _c.length;
  return typeof line === "number" ? line : void 0;
}
function retry(cb, interval, trials, check = (got) => got !== void 0) {
  return __async(this, null, function* () {
    for (let i = 0; i < trials; i++) {
      const got = cb();
      if (check(got)) {
        return got;
      }
      yield delay(interval);
    }
    return void 0;
  });
}
function shallowClone(obj) {
  return Object.assign({}, obj);
}
function deepClone(obj) {
  if (obj === null)
    return obj;
  if (typeof obj !== "object")
    return obj;
  if (obj instanceof Array) {
    const clone2 = new Array(obj.length);
    obj.forEach((value, id) => {
      clone2[id] = deepClone(value);
    });
    return clone2;
  }
  const clone = shallowClone(obj);
  for (const key in clone) {
    const value = clone[key];
    clone[key] = deepClone(value);
  }
  return clone;
}
function deepMerge(a, b) {
  if (b === void 0) {
    return deepClone(a);
  } else if (a === void 0) {
    return deepClone(b);
  }
  if (typeof a !== typeof b) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  if (typeof b !== "object")
    return deepClone(b);
  if (b === null) {
    return deepClone(a);
  } else if (a === null) {
    return deepClone(b);
  }
  if (b instanceof Array) {
    if (a instanceof Array) {
      return deepClone(b);
    } else {
      throw new Error(`failed to deepMerge ${a} and ${b}`);
    }
  } else if (a instanceof Array) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  const clone = shallowClone(a);
  for (const key in a) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  for (const key in b) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  return clone;
}

// src/interfaces/ViewGenerator.ts
var ViewGenerator = class {
  constructor(app, containerEl, file) {
    this.extensions = [];
    this.app = app;
    this.containerEl = containerEl;
    this.leaf = new import_obsidian8.WorkspaceLeaf(this.app);
    this.file = file;
    this.containerEl.appendChild(this.leaf.containerEl);
  }
  load(mode) {
    return __async(this, null, function* () {
      yield this.onload(mode);
      return this;
    });
  }
  unload() {
    return __async(this, null, function* () {
      this.onunload();
    });
  }
  toggleViewMode() {
    return __async(this, null, function* () {
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.toggleViewMode(this.leaf);
        return;
      }
    });
  }
  onload(mode) {
    return __async(this, null, function* () {
      yield this.openFile();
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.setViewMode(this.leaf, mode != null ? mode : "preview");
        return;
      }
    });
  }
  onunload() {
    this.leaf.detach();
  }
  openFile() {
    return __async(this, null, function* () {
      const { leaf, file } = this;
      yield leaf.openFile(file);
    });
  }
  highlightMatches(matches) {
    const view = this.leaf.view;
    if (!(view instanceof import_obsidian8.MarkdownView)) {
      return;
    }
    const editor = view.editor;
    const ranges = [];
    matches.forEach((match) => {
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      ranges.push(range);
    });
    editor.addHighlights(ranges, "highlight-search-match");
  }
  scrollIntoView(match, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian8.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, center);
        yield delay(1);
      }
    });
  }
  focusOn(match, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian8.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      yield this.scrollIntoView(match, center);
      const { editor } = view;
      editor.removeHighlights("focus-search-match");
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], "focus-search-match");
    });
  }
  registerExtension(ext) {
    this.extensions.push(ext);
    return this;
  }
};

// src/components/WorkspacePreview.ts
var import_obsidian9 = __toModule(require("obsidian"));
var INTERVAL_MILLISECOND_TO_BE_DETACHED = 1e3;
var WorkspacePreview = class extends import_obsidian9.Component {
  constructor(app, plugin) {
    super();
    this.app = app;
    this.plugin = plugin;
    this.containerEl = this.createContainerEl();
  }
  onload() {
    this.hide();
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.rootSplit.containerEl.appendChild(this.containerEl);
    });
  }
  onunload() {
    var _a;
    (_a = this.renderer) == null ? void 0 : _a.unload();
    this.containerEl.empty();
    this.containerEl.remove();
  }
  renew(item) {
    this.requestUnloadRenderer(INTERVAL_MILLISECOND_TO_BE_DETACHED);
    this.show(item);
  }
  hide() {
    this.containerEl.hide();
    this.requestUnloadRenderer(INTERVAL_MILLISECOND_TO_BE_DETACHED);
  }
  createContainerEl() {
    return createEl("div", {
      attr: {
        id: "core-search-assistant_workspace-preview"
      }
    });
  }
  requestUnloadRenderer(millisecond) {
    const { renderer } = this;
    this.renderer = void 0;
    setTimeout(() => {
      renderer == null ? void 0 : renderer.unload();
    }, millisecond);
  }
  show(item) {
    return __async(this, null, function* () {
      const { containerEl } = this;
      containerEl.empty();
      this.renderer = yield new ViewGenerator(this.app, containerEl, item.file).load("preview");
      containerEl.show();
    });
  }
};

// src/interfaces/viewGeneratorExtensions/Kanban.ts
var import_obsidian10 = __toModule(require("obsidian"));
var kanbanPluginId = "obsidian-kanban";
var frontMatterKey = "kanban-plugin";
var kanbanViewType = "kanban";
var KanbanViewGeneratorExtension = class {
  constructor(app) {
    this.app = app;
    const kanban = this.app.plugins.plugins[kanbanPluginId];
    if (IsKanbanPlugin(kanban)) {
      this.kanban = kanban;
    }
    if (kanban === void 0) {
      console.log("[ERROR in Core Search Assistant] failed to fetch kanban plugin");
      this.kanban = void 0;
    }
  }
  isMine(leaf) {
    const { view } = leaf;
    if (view.getViewType() == kanbanViewType)
      return true;
    if (!(view instanceof import_obsidian10.TextFileView))
      return false;
    const fileCache = this.app.metadataCache.getFileCache(view.file);
    const fileIsKanban = !!(fileCache == null ? void 0 : fileCache.frontmatter) && !!fileCache.frontmatter[frontMatterKey];
    return fileIsKanban;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      if (mode === "source") {
        kanban.kanbanFileModes[leaf.id] = "markdown";
        yield kanban.setMarkdownView(leaf);
        yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
          mode: "source"
        }), {});
      } else {
        kanban.kanbanFileModes[leaf.id] = kanbanViewType;
        yield kanban.setKanbanView(leaf);
      }
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      const mode = kanban.kanbanFileModes[leaf.id];
      yield this.setViewMode(leaf, mode === "markdown" ? "preview" : "source");
    });
  }
};
function IsKanbanPlugin(plugin) {
  if (!(plugin instanceof import_obsidian10.Plugin))
    return false;
  const { kanbanFileModes, setKanbanView, setMarkdownView } = plugin;
  if (typeof kanbanFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  if (typeof setKanbanView !== "function")
    return false;
  return true;
}

// src/interfaces/viewGeneratorExtensions/Markdown.ts
var import_obsidian11 = __toModule(require("obsidian"));
var MarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    return leaf.view instanceof import_obsidian11.MarkdownView;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      if (!(leaf.view instanceof import_obsidian11.MarkdownView))
        return;
      yield this.setViewMode(leaf, leaf.view.getMode() === "preview" ? "source" : "preview");
    });
  }
};

// src/interfaces/viewGeneratorExtensions/NonMarkdown.ts
var import_obsidian12 = __toModule(require("obsidian"));
var NON_MARKDOWN_FILE_TYPES = ["image", "audio", "pdf", "video"];
var NonMarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    if (!(leaf.view instanceof import_obsidian12.FileView))
      return false;
    return NON_MARKDOWN_FILE_TYPES.includes(leaf.view.getViewType());
  }
  setViewMode(_leaf, _mode) {
    return;
  }
  toggleViewMode(_) {
    return;
  }
};

// src/interfaces/viewGeneratorExtensions/Excalidraw.ts
var import_obsidian13 = __toModule(require("obsidian"));
var excalidrawPluginId = "obsidian-excalidraw-plugin";
var excalidrawViewType = "excalidraw";
var ExcalidrawViewGeneratorExtension = class {
  constructor(app) {
    this.app = app;
    const excalidraw = this.app.plugins.plugins[excalidrawPluginId];
    if (!isExcalidrawPlugin(excalidraw)) {
      this.excalidraw = void 0;
    } else {
      this.excalidraw = excalidraw;
    }
  }
  isMine(leaf) {
    return leaf.view.getViewType() === excalidrawViewType;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian13.MarkdownView))
        return;
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian13.MarkdownView))
        return;
      const mode = leaf.view.getMode();
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode: mode === "preview" ? "source" : "preview"
      }), {});
    });
  }
};
function isExcalidrawPlugin(plugin) {
  if (!(plugin instanceof import_obsidian13.Plugin))
    return false;
  const { excalidrawFileModes, setMarkdownView } = plugin;
  if (typeof excalidrawFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  return true;
}

// src/utils/Link.ts
function generateInternalLinkFrom(metadataCache, file) {
  const link = metadataCache.fileToLinktext(file, "", true);
  const text2 = getDisplayText(metadataCache, file);
  return text2 !== void 0 ? `[[${link} | ${text2}]]` : `[[${link}]]`;
}
function getDisplayText(metadataCache, file) {
  const cache = metadataCache.getFileCache(file);
  if (!cache)
    return void 0;
  const title = getTitle(cache.frontmatter);
  if (title !== void 0) {
    return title;
  }
  const h1 = getFirstH1(cache.headings);
  if (h1 !== void 0) {
    return h1;
  }
  return void 0;
}
function getTitle(frontmatter) {
  return frontmatter == null ? void 0 : frontmatter["title"];
}
function getFirstH1(headings) {
  if (!headings)
    return void 0;
  for (const heading of headings) {
    if (heading.level !== 1)
      continue;
    return heading.heading;
  }
  return void 0;
}

// src/components/PreviewModal.ts
var SCROLL_AMOUNT = 70;
var PreviewModal = class extends import_obsidian14.Modal {
  constructor(app, plugin, modeScope, item) {
    super(app);
    this.plugin = plugin;
    this.modeScope = modeScope;
    this.item = item;
    this.currentFocus = -1;
  }
  onOpen() {
    return __async(this, null, function* () {
      var _a;
      yield this.renderView();
      this.highlightMatches();
      this.modeScope.push();
      const hotkeyMap = (_a = this.plugin.settings) == null ? void 0 : _a.previewModalHotkeys;
      if (!hotkeyMap)
        return;
      hotkeyMap.closeModal.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.shouldRestoreSelection = true;
          this.close();
        });
      });
      hotkeyMap.open.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          var _a2;
          this.openAndFocus(this.currentFocus);
          (_a2 = this.plugin.controller) == null ? void 0 : _a2.exit();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.openInNewPage.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          var _a2, _b;
          this.openAndFocus(this.currentFocus, (_a2 = this.plugin.settings) == null ? void 0 : _a2.splitDirection);
          (_b = this.plugin.controller) == null ? void 0 : _b.exit();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.bigScrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("down");
        });
      });
      hotkeyMap.bigScrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("up");
        });
      });
      hotkeyMap.scrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("down", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.scrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("up", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.focusNext.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          this.currentFocus = cyclicId(++this.currentFocus, numMatches);
          this.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.focusPrevious.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          this.currentFocus = cyclicId(--this.currentFocus, numMatches);
          this.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.togglePreviewMode.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          (() => __async(this, null, function* () {
            evt.preventDefault();
            yield this.toggleViewMode();
            this.highlightMatches();
          }))();
        });
      });
      hotkeyMap.copyLink.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          const { file } = this.item;
          const internalLink = generateInternalLinkFrom(this.app.metadataCache, file);
          navigator.clipboard.writeText(internalLink);
          new import_obsidian14.Notice("Copy wiki link!");
        });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.requestUnloadRenderer(INTERVAL_MILLISECOND_TO_BE_DETACHED);
    setTimeout(() => {
      if (this.modeScope.depth > 1) {
        this.modeScope.pop();
      }
    }, 100);
  }
  requestUnloadRenderer(millisecond) {
    const renderer = this.renderer;
    this.renderer = void 0;
    setTimeout(() => {
      renderer == null ? void 0 : renderer.unload();
    }, millisecond);
  }
  renderView() {
    return __async(this, null, function* () {
      const { contentEl, containerEl, item } = this;
      contentEl.empty();
      contentEl.hide();
      if (this.app.vault.config.legacyEditor) {
        containerEl.addClass("core-search-assistant_preview-modal-container_legacy");
      } else {
        containerEl.addClass("core-search-assistant_preview-modal-container");
      }
      this.renderer = yield new ViewGenerator(this.app, contentEl, item.file).registerExtension(new KanbanViewGeneratorExtension(this.app)).registerExtension(new ExcalidrawViewGeneratorExtension(this.app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("source");
      contentEl.show();
    });
  }
  countMatches() {
    var _a;
    return (_a = this.item.result.content) == null ? void 0 : _a.length;
  }
  toggleViewMode() {
    return __async(this, null, function* () {
      var _a;
      yield (_a = this.renderer) == null ? void 0 : _a.toggleViewMode();
    });
  }
  highlightMatches() {
    var _a, _b;
    (_b = this.renderer) == null ? void 0 : _b.highlightMatches((_a = this.item.result.content) != null ? _a : []);
  }
  scroll(direction, px) {
    const { containerEl, contentEl } = this;
    const move = (px != null ? px : containerEl.clientHeight / 2) * (direction === "up" ? -1 : 1);
    contentEl.scrollBy({
      top: move,
      behavior: "smooth"
    });
  }
  focusOn(matchId, center) {
    var _a;
    const { renderer, item } = this;
    const match = (_a = item.result.content) == null ? void 0 : _a[matchId];
    if (match === void 0) {
      return;
    }
    renderer == null ? void 0 : renderer.focusOn(match, center);
  }
  openAndFocus(matchId, direction) {
    return __async(this, null, function* () {
      var _a, _b;
      const { item } = this;
      const leaf = direction === void 0 ? this.app.workspace.getMostRecentLeaf() : this.app.workspace.splitActiveLeaf(direction);
      yield leaf.openFile(item.file, {
        state: {
          mode: "source"
        }
      });
      this.app.workspace.setActiveLeaf(leaf, true, true);
      const match = (_b = (_a = item == null ? void 0 : item.result) == null ? void 0 : _a.content) == null ? void 0 : _b[matchId];
      if (!match) {
        return;
      }
      const { view } = leaf;
      if (!(view instanceof import_obsidian14.MarkdownView)) {
        throw "[ERROR in Core Search Assistant] failed to openAndFocus: view is not an instance of MarkdownView";
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], "obsidian-search-match-highlight");
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, true);
      }
      editor.setCursor(range.from);
    });
  }
};
function cyclicId(id, total) {
  return (id % total + total) % total;
}

// src/components/Outline.ts
var import_obsidian15 = __toModule(require("obsidian"));
var Outline = class extends import_obsidian15.Component {
  constructor(lineWidth) {
    super();
    this.outlineEl = document.body.createEl("div", {
      cls: "core-search-assistant_search-mode-outline"
    });
    this.lineWidth = lineWidth;
  }
  onload() {
    this.setWidth(this.lineWidth);
  }
  onunload() {
    this.outlineEl.remove();
  }
  setWidth(lineWidth) {
    this.outlineEl.style.outline = `${lineWidth}px solid var(--interactive-accent)`;
    this.outlineEl.style.outlineOffset = `-${lineWidth}px`;
    this.outlineEl.show();
  }
};

// src/components/CardView.ts
var import_obsidian16 = __toModule(require("obsidian"));
var CardView = class extends import_obsidian16.Component {
  constructor(app, plugin) {
    super();
    this.app = app;
    this.plugin = plugin;
    this.containerEl = this.createContainerEl();
    this.contentEl = this.createContentEl();
    this.renderers = [];
  }
  onload() {
    this.registerDomEvent(this.contentEl, "click", this.onCardItemClicked);
    this.attachContainerEl();
  }
  onunload() {
    this.requestUnloadRenderers();
    this.containerEl.empty();
    this.containerEl.remove();
  }
  renderItem(item, id) {
    this.renderItemByViewGenerator(item, id);
  }
  focusOn(pos) {
    const { contentEl } = this;
    const cardEls = contentEl.childNodes;
    [-1, 0, 1].forEach((i) => {
      const el = cardEls.item(pos + i);
      if (!(el instanceof HTMLElement)) {
        return;
      }
      if (i === 0) {
        el.addClass("is-selected");
      } else {
        el.removeClass("is-selected");
      }
    });
  }
  unfocus() {
    const { contentEl } = this;
    const cardEls = contentEl.childNodes;
    cardEls.forEach((el) => {
      if (!(el instanceof HTMLElement)) {
        return;
      }
      el.removeClass("is-selected");
    });
  }
  clear() {
    this.requestUnloadRenderers();
    this.containerEl.hide();
    this.contentEl.empty();
  }
  renderPage(itemId) {
    var _a;
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0) {
      return;
    }
    const pageId = Math.floor(itemId / cardsPerPage);
    const items = (_a = this.plugin.searchInterface) == null ? void 0 : _a.resultItems;
    if (!items) {
      return;
    }
    for (let i = pageId * cardsPerPage; i < (pageId + 1) * cardsPerPage; i++) {
      const item = items[i];
      if (!item) {
        continue;
      }
      this.renderItem(item, i);
    }
    this.setLayout();
  }
  reveal() {
    this.containerEl.show();
  }
  setLayout() {
    if (!this.plugin.settings) {
      return;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    this.contentEl.style.gridTemplateColumns = `repeat(${column}, minmax(0, 1fr))`;
    this.contentEl.style.gridTemplateRows = `repeat(${row}, 1fr)`;
  }
  get itemsRenderedCorrectly() {
    var _a;
    const wantedItems = (_a = this.plugin.searchInterface) == null ? void 0 : _a.resultItems;
    if (wantedItems === void 0) {
      return false;
    }
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0) {
      return false;
    }
    const length = Math.min(wantedItems.length, cardsPerPage);
    const gotItemEls = this.contentEl.children;
    for (let i = 0; i < length; i++) {
      const want = wantedItems[i];
      const got = gotItemEls.item(i);
      if (want === void 0) {
        if (got === null) {
          continue;
        } else {
          return false;
        }
      }
      if (!(got instanceof HTMLElement)) {
        return false;
      }
      if (got.dataset["path"] !== want.file.path) {
        return false;
      }
    }
    return true;
  }
  createContainerEl() {
    const containerEl = createEl("div", {
      attr: { id: `core-search-assistant_card-view` }
    });
    return containerEl;
  }
  attachContainerEl() {
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.rootSplit.containerEl.appendChild(this.containerEl);
      this.containerEl.hide();
    });
  }
  createContentEl() {
    let row = 0;
    let column = 0;
    if (this.plugin.settings) {
      [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    }
    const contentEl = this.containerEl.createEl("div", {
      cls: "content"
    });
    contentEl.style.gridTemplateColumns = `repeat(${column}, minmax(0, 1fr))`;
    contentEl.style.gridTemplateRows = `repeat(${row}, 1fr)`;
    return contentEl;
  }
  renderItemByViewGenerator(item, id) {
    return __async(this, null, function* () {
      const previewContainerEl = this.createPreviewContainerEl(item, id);
      previewContainerEl.empty();
      if (supportedFileTypes.includes(item.file.extension)) {
        const renderer = yield new ViewGenerator(this.app, previewContainerEl, item.file).registerExtension(new KanbanViewGeneratorExtension(this.app)).registerExtension(new ExcalidrawViewGeneratorExtension(this.app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("preview");
        this.renderers.push(renderer);
      } else {
        previewContainerEl.createDiv({
          text: `${item.file.extension} file`,
          cls: "unsupported-file-content"
        });
      }
    });
  }
  requestUnloadRenderers() {
    const renderersToUnload = this.renderers;
    this.renderers = [];
    setTimeout(() => {
      renderersToUnload.forEach((renderer) => {
        renderer.unload();
      });
    }, INTERVAL_MILLISECOND_TO_BE_DETACHED);
  }
  createPreviewContainerEl(item, id) {
    var _a;
    const { contentEl } = this;
    const itemContainerEl = contentEl.createEl("div", {
      cls: "item-container",
      attr: {
        "data-id": id,
        "data-path": item.file.path
      }
    });
    itemContainerEl.createEl("div", {
      cls: "file-name-container",
      text: item.file.extension === "md" ? item.file.basename : item.file.name
    });
    const previewMarginEl = itemContainerEl.createEl("div", {
      cls: "preview-container-wrapper"
    });
    const previewContainerEl = previewMarginEl.createEl("div", {
      cls: "preview-container"
    });
    if ((_a = this.plugin.settings) == null ? void 0 : _a.hideIframe) {
      previewContainerEl.addClass("hide-iframe");
    }
    return previewContainerEl;
  }
  getSelectedCardEl(el) {
    const parentEl = el.parentElement;
    if (el.tagName === "DIV" && parentEl === this.contentEl) {
      return el;
    }
    if (parentEl === null) {
      return void 0;
    }
    return this.getSelectedCardEl(parentEl);
  }
  cardsPerPage() {
    if (!this.plugin.settings) {
      return void 0;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    return row * column;
  }
  get onCardItemClicked() {
    return (evt) => {
      var _a;
      if (!(evt.target instanceof HTMLElement)) {
        return;
      }
      const cardEl = this.getSelectedCardEl(evt.target);
      if (!cardEl) {
        return;
      }
      const id = cardEl.dataset["id"];
      if (id === void 0) {
        return;
      }
      (_a = this.plugin.searchInterface) == null ? void 0 : _a.open(Number.parseInt(id));
    };
  }
};
var supportedFileTypes = [
  "md",
  "png",
  "jpg",
  "jpeg",
  "gif",
  "bmp",
  "svg",
  "mp3",
  "webm",
  "wav",
  "m4a",
  "ogg",
  "3gp",
  "flac",
  "mp4",
  "ogv",
  "pdf"
];

// src/ModeScope.ts
var ModeScope = class {
  constructor() {
    this._depth = 0;
  }
  get inSearchMode() {
    return this._depth > 0;
  }
  get depth() {
    return this._depth;
  }
  push() {
    this._depth++;
  }
  pop() {
    this._depth--;
    if (this.depth < 0) {
      throw "[ERROR in Core Search Assistant] ModeScope.depth < 0";
    }
  }
  reset() {
    this._depth = 0;
  }
};

// src/Controller.ts
var import_obsidian17 = __toModule(require("obsidian"));
var DELAY_TO_RELOAD_IN_MILLISECOND = 1e3;
var RETRY_INTERVAL = 1;
var RETRY_TRIALS = 1e3;
var DELAY_TO_RENDER_CARD_VIEW_ON_ENTRY_IN_MILLISECOND = 100;
var Controller = class extends obsidian.Component {
  constructor(app, plugin, events, searchInterface) {
    super();
    this.app = app;
    this.plugin = plugin;
    this.events = events;
    this.searchInterface = searchInterface;
    this.modeScope = new ModeScope();
    this.countSearchItemDetected = 0;
  }
  onunload() {
    this.exit();
  }
  onload() {
    this.saveLayout();
    this.setSearchModeTriggers();
  }
  enter() {
    return __async(this, null, function* () {
      var _a, _b;
      if (this.modeScope.inSearchMode) {
        return;
      }
      this.setHotkeys();
      this.addChildren();
      if ((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar) {
        this.collapseOppositeSidedock();
      }
      const shouldDetectSearchItems = ((_b = this.plugin.settings) == null ? void 0 : _b.autoPreviewMode) === "cardView" && this.plugin.settings.renderCardsManually === false;
      if (shouldDetectSearchItems) {
        this.searchInterface.startWatching(this.events);
        yield delay(DELAY_TO_RENDER_CARD_VIEW_ON_ENTRY_IN_MILLISECOND);
        this.renewCardViewPage();
      }
      this.modeScope.push();
    });
  }
  reset() {
    var _a;
    if (!this.modeScope.inSearchMode) {
      return;
    }
    this.forget();
    this.unfocus();
    (_a = this.cardView) == null ? void 0 : _a.clear();
    this.countSearchItemDetected = 0;
  }
  exit(reason) {
    var _a;
    if (!this.modeScope.inSearchMode) {
      return;
    }
    this.reset();
    this.detachHotkeys();
    this.removeChildren();
    if (this.shouldCollapseSidedock(reason)) {
      this.collapseSidedock();
    }
    if ((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar) {
      this.restoreOppositeSidedock();
    }
    this.countSearchItemDetected = 0;
    this.searchInterface.stopWatching();
    this.unfocus();
    this.modeScope.reset();
  }
  focus() {
    var _a;
    if (this.currentFocusId === void 0) {
      return;
    }
    this.searchInterface.focusOn(this.currentFocusId);
    const pos = this.positionInCardView(this.currentFocusId);
    if (pos === void 0) {
      return;
    }
    (_a = this.cardView) == null ? void 0 : _a.focusOn(pos);
  }
  open(direction) {
    if (this.currentFocusId === void 0) {
      return;
    }
    this.searchInterface.open(this.currentFocusId, direction);
  }
  renewCardViewPage() {
    var _a, _b, _c, _d, _e;
    if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) !== "cardView") {
      return;
    }
    (_b = this.cardView) == null ? void 0 : _b.clear();
    (_d = this.cardView) == null ? void 0 : _d.renderPage((_c = this.currentFocusId) != null ? _c : 0);
    (_e = this.cardView) == null ? void 0 : _e.reveal();
  }
  collapseSidedock() {
    var _a;
    (_a = this.plugin.searchInterface) == null ? void 0 : _a.collapseSidedock();
  }
  collapseOppositeSidedock() {
    var _a, _b, _c;
    const collapsed = (_b = (_a = this.plugin.searchInterface) == null ? void 0 : _a.oppositeSidedock) == null ? void 0 : _b.collapsed;
    (_c = this.plugin.searchInterface) == null ? void 0 : _c.collapseOppositeSidedock();
    this._restoreOppositeSidedock = () => {
      var _a2;
      if (collapsed === false) {
        (_a2 = this.plugin.searchInterface) == null ? void 0 : _a2.expandOppositeSidedock();
      }
    };
  }
  restoreOppositeSidedock() {
    const restoreOppositeSidedock = this._restoreOppositeSidedock;
    if (restoreOppositeSidedock === void 0) {
      return void 0;
    }
    return restoreOppositeSidedock();
  }
  addChildren() {
    this.removeChildren();
    if (this.plugin.settings === void 0) {
      throw "[ERROR in Core Search Assistant] failed to addChildren: failed to read setting";
    }
    this.outline = this.addChild(new Outline(this.plugin.settings.outlineWidth));
    this.cardView = this.addChild(new CardView(this.app, this.plugin));
    this.workspacePreview = this.addChild(new WorkspacePreview(this.app, this.plugin));
  }
  removeChildren() {
    if (this.outline) {
      this.removeChild(this.outline);
    }
    if (this.cardView) {
      this.removeChild(this.cardView);
    }
    if (this.workspacePreview) {
      this.removeChild(this.workspacePreview);
    }
  }
  forget() {
    this.currentFocusId = void 0;
    this.countSearchItemDetected = 0;
  }
  showCardViewItem(id) {
    var _a, _b, _c;
    const item = this.searchInterface.getResultItemAt(id);
    if (!item) {
      return;
    }
    (_a = this.cardView) == null ? void 0 : _a.renderItem(item, id);
    (_b = this.cardView) == null ? void 0 : _b.setLayout();
    (_c = this.cardView) == null ? void 0 : _c.reveal();
  }
  showWorkspacePreview() {
    var _a, _b, _c;
    if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) !== "singleView") {
      return;
    }
    const item = this.searchInterface.getResultItemAt((_b = this.currentFocusId) != null ? _b : 0);
    if (!item) {
      return;
    }
    (_c = this.workspacePreview) == null ? void 0 : _c.renew(item);
  }
  navigateForward() {
    var _a;
    if (this.currentFocusId === void 0) {
      this.currentFocusId = 0;
    } else {
      const numResults = (_a = this.searchInterface.count()) != null ? _a : 0;
      this.currentFocusId++;
      this.currentFocusId = this.currentFocusId < numResults ? this.currentFocusId : numResults - 1;
      if (this.shouldTransitNextPageInCardView()) {
        this.renewCardViewPage();
      }
    }
    this.focus();
  }
  navigateBack() {
    if (this.currentFocusId === void 0) {
      return;
    }
    this.currentFocusId--;
    this.currentFocusId = this.currentFocusId >= 0 ? this.currentFocusId : 0;
    if (this.shouldTransitPreviousPageInCardView()) {
      this.renewCardViewPage();
    }
    this.focus();
  }
  moveToNextPage() {
    const pageId = this.pageId;
    if (pageId === void 0)
      return;
    const pageCount = this.pageCount;
    if (pageCount === void 0)
      return;
    if (pageId >= pageCount - 1)
      return;
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0)
      return;
    this.currentFocusId = cardsPerPage * (pageId + 1);
    this.renewCardViewPage();
    this.focus();
  }
  moveToPreviousPage() {
    const pageId = this.pageId;
    if (pageId === void 0)
      return;
    const pageCount = this.pageCount;
    if (pageCount === void 0)
      return;
    if (pageId <= 0)
      return;
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0)
      return;
    this.currentFocusId = cardsPerPage * (pageId - 1);
    this.renewCardViewPage();
    this.focus();
  }
  unfocus() {
    var _a;
    this.searchInterface.unfocus();
    (_a = this.cardView) == null ? void 0 : _a.unfocus();
  }
  openPreviewModal() {
    const { currentFocusId } = this;
    if (currentFocusId === void 0) {
      return;
    }
    const item = this.searchInterface.getResultItemAt(currentFocusId);
    if (!item) {
      return;
    }
    new PreviewModal(this.app, this.plugin, this.modeScope, item).open();
  }
  shouldTransitNextPageInCardView() {
    if (!this.plugin.settings) {
      return false;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    const cardsPerPage = row * column;
    if (this.currentFocusId === void 0) {
      return false;
    }
    return this.currentFocusId % cardsPerPage === 0;
  }
  shouldTransitPreviousPageInCardView() {
    if (!this.plugin.settings) {
      return false;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    const cardsPerPage = row * column;
    if (this.currentFocusId === void 0) {
      return false;
    }
    return (this.currentFocusId + 1) % cardsPerPage === 0;
  }
  positionInCardView(id) {
    if (id === void 0) {
      return void 0;
    }
    const cardsPerPage = this.cardsPerPage();
    if (!cardsPerPage) {
      return void 0;
    }
    return id % cardsPerPage;
  }
  get pageId() {
    if (this.currentFocusId === void 0)
      return void 0;
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0)
      return void 0;
    const pageId = Math.floor(this.currentFocusId / cardsPerPage);
    return pageId;
  }
  get pageCount() {
    var _a;
    const numResults = (_a = this.plugin.searchInterface) == null ? void 0 : _a.count();
    const cardsPerPage = this.cardsPerPage();
    if (cardsPerPage === void 0)
      return void 0;
    const pageCount = Math.ceil((numResults != null ? numResults : 0) / cardsPerPage);
    return pageCount;
  }
  cardsPerPage() {
    if (!this.plugin.settings) {
      return void 0;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    return row * column;
  }
  retryCardView(delayMillisecond) {
    setTimeout(() => {
      var _a;
      if (!((_a = this.cardView) == null ? void 0 : _a.itemsRenderedCorrectly)) {
        this.reset();
        this.renewCardViewPage();
      }
    }, delayMillisecond);
  }
  saveLayout() {
    this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
      const inputEl = yield retry(() => this.searchInterface.searchInputEl, RETRY_INTERVAL, RETRY_TRIALS);
      this._layoutChanged = () => __async(this, null, function* () {
        return inputEl !== (yield retry(() => this.searchInterface.searchInputEl, RETRY_INTERVAL, RETRY_TRIALS));
      });
    }));
  }
  layoutChanged() {
    return __async(this, null, function* () {
      var _a;
      const required = yield (_a = this._layoutChanged) == null ? void 0 : _a.call(this);
      if (required === void 0) {
        throw "[ERROR in Core Search Assistant] failed to renewRequired: saveLayout was not called.";
      }
      return required;
    });
  }
  setSearchModeTriggers() {
    this.registerEvent(this.events.on(EVENT_SEARCH_RESULT_ITEM_DETECTED, this.onSearchResultItemDetected));
    this.registerEvent(this.events.on(EVENT_SORT_ORDER_CHANGED, this.onSortOrderChanged));
    this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
      const appContainerEl = yield retry(() => this.app.dom.appContainerEl, RETRY_INTERVAL, RETRY_TRIALS);
      if (appContainerEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the app container element";
      }
      const inputEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchInputEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (inputEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the search input form.";
      }
      const matchingCaseButtonEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.matchingCaseButtonEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (matchingCaseButtonEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the matching case button.";
      }
      this.registerDomEvent(appContainerEl, "click", (evt) => {
        var _a, _b, _c, _d, _e;
        const targetEl = evt.target;
        if (!(targetEl instanceof HTMLElement)) {
          return;
        }
        if ((_b = (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchLeaf) == null ? void 0 : _b.containerEl.contains(targetEl)) {
          if (!this.plugin.searchInterface.isBuiltInElementToOpenFile(targetEl))
            return;
        }
        if ((_d = (_c = this.plugin.searchInterface) == null ? void 0 : _c.tabHeaderEl) == null ? void 0 : _d.contains(targetEl)) {
          return;
        }
        if ((_e = this.plugin.searchInterface) == null ? void 0 : _e.isShowMoreContextButton(targetEl)) {
          return;
        }
        if (this.modeScope.depth === 1) {
          this.exit({ id: "mouse", event: evt });
        }
      });
      this.registerDomEvent(matchingCaseButtonEl, "click", () => {
        if (this.modeScope.inSearchMode) {
          this.reset();
        }
      });
      this.registerDomEvent(inputEl, "click", () => {
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
      });
      this.registerDomEvent(inputEl, "input", () => {
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
        this.reset();
      });
      this.registerDomEvent(inputEl, "keypress", (evt) => {
        if (evt.key !== "Enter") {
          return;
        }
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
        this.reset();
      });
      this.registerDomEvent(inputEl, "focus", () => {
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
      });
    }));
  }
  setHotkeys() {
    var _a;
    const hotkeyMap = (_a = this.plugin.settings) == null ? void 0 : _a.searchModeHotkeys;
    if (!hotkeyMap)
      return;
    const scope = new obsidian.Scope();
    this.app.keymap.pushScope(scope);
    hotkeyMap.selectNext.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.navigateForward();
        this.showWorkspacePreview();
      });
    });
    hotkeyMap.selectPrevious.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.navigateBack();
        this.showWorkspacePreview();
      });
    });
    hotkeyMap.open.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.open();
        this.exit();
      });
    });
    hotkeyMap.openInNewPane.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a2;
        evt.preventDefault();
        this.open((_a2 = this.plugin.settings) == null ? void 0 : _a2.splitDirection);
        this.exit();
      });
    });
    hotkeyMap.previewModal.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        if (this.app.vault.config.legacyEditor) {
          return;
        }
        this.openPreviewModal();
      });
    });
    hotkeyMap.showOptions.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        new OptionModal(this.app, this.plugin, this.modeScope).open();
      });
    });
    hotkeyMap.nextPage.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        if (((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView") {
          this.moveToNextPage();
        }
      });
    });
    hotkeyMap.previousPage.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        if (((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView") {
          this.moveToPreviousPage();
        }
      });
    });
    hotkeyMap.copyLink.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        const item = this.searchInterface.getResultItemAt((_a2 = this.currentFocusId) != null ? _a2 : 0);
        if (!item)
          return;
        const { file } = item;
        const internalLink = generateInternalLinkFrom(this.app.metadataCache, file);
        navigator.clipboard.writeText(internalLink);
        new import_obsidian17.Notice("Copy wiki link!");
      });
    });
    scope.register([], "Escape", () => {
      this.exit();
    });
    scope.register([], "Enter", (evt) => {
      var _a2;
      setTimeout(this.focusOnInput, 100);
      const shouldRenderCardsManually = ((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView" && this.plugin.settings.renderCardsManually;
      if (shouldRenderCardsManually) {
        evt.preventDefault();
        this.reset();
        this.renewCardViewPage();
      }
    });
    this._detachHotkeys = () => {
      this.app.keymap.popScope(scope);
    };
  }
  detachHotkeys() {
    const detachHotkeys = this._detachHotkeys;
    if (detachHotkeys === void 0) {
      return;
    }
    detachHotkeys();
  }
  get onSearchResultItemDetected() {
    return () => {
      var _a, _b;
      if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) !== "cardView") {
        return;
      }
      if (this.currentFocusId !== void 0) {
        return;
      }
      const cardsPerPage = this.cardsPerPage();
      if (cardsPerPage === void 0) {
        return;
      }
      if (this.countSearchItemDetected >= cardsPerPage) {
        return;
      }
      if (this.countSearchItemDetected === 0) {
        (_b = this.cardView) == null ? void 0 : _b.clear();
      }
      this.showCardViewItem(this.countSearchItemDetected);
      if (this.countSearchItemDetected === 0) {
        this.retryCardView(DELAY_TO_RELOAD_IN_MILLISECOND);
      }
      this.countSearchItemDetected++;
    };
  }
  get focusOnInput() {
    return () => __async(this, null, function* () {
      const inputEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchInputEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (inputEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the search input form.";
      }
      inputEl.focus();
    });
  }
  get onSortOrderChanged() {
    return () => {
      var _a;
      this.reset();
      if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) === "cardView") {
        this.renewCardViewPage();
      }
    };
  }
  shouldCollapseSidedock(reason) {
    var _a, _b;
    if (!((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar)) {
      return false;
    }
    if (reason === void 0) {
      return true;
    }
    if (reason.id !== "mouse") {
      return true;
    }
    const targetEl = reason.event.target;
    if (!(targetEl instanceof HTMLElement)) {
      return true;
    }
    return !((_b = this.searchInterface.sideDock) == null ? void 0 : _b.containerEl.contains(targetEl));
  }
};

// src/interfaces/SearchComponentInterface.ts
var import_obsidian19 = __toModule(require("obsidian"));

// src/types/Guards.ts
var import_obsidian18 = __toModule(require("obsidian"));
var SORT_ORDER_IN_SEARCH = [
  "alphabeticalReverse",
  "alphabetical",
  "byModifiedTime",
  "byModifiedTimeReverse",
  "byCreatedTime",
  "byCreatedTimeReverse"
];
function isSearchView(view) {
  if (typeof view !== "object") {
    return false;
  }
  if (view === null) {
    return false;
  }
  const {
    matchingCase,
    explainSearch,
    dom,
    setCollapseAll,
    setExplainSearch,
    setExtraContext,
    setMatchingCase,
    setSortOrder,
    searchInfoEl,
    searchComponent,
    headerDom
  } = view;
  if (typeof matchingCase !== "boolean") {
    return false;
  }
  if (typeof explainSearch !== "boolean") {
    return false;
  }
  if (!isSearchDom(dom)) {
    return false;
  }
  if (typeof searchComponent !== "object") {
    return false;
  }
  if (typeof searchInfoEl !== "object") {
    return false;
  }
  if (!(searchInfoEl instanceof HTMLDivElement)) {
    return false;
  }
  if (!isSearchHeaderDom(headerDom)) {
    return false;
  }
  if (!(setCollapseAll instanceof Function)) {
    return false;
  }
  if (!(setExplainSearch instanceof Function)) {
    return false;
  }
  if (!(setExtraContext instanceof Function)) {
    return false;
  }
  if (!(setMatchingCase instanceof Function)) {
    return false;
  }
  if (!(setSortOrder instanceof Function)) {
    return false;
  }
  return true;
}
function isSearchDom(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (obj === null) {
    return false;
  }
  const { extraContext, collapseAll, sortOrder, children: children2, childrenEl } = obj;
  if (typeof extraContext !== "boolean") {
    return false;
  }
  if (typeof collapseAll !== "boolean") {
    return false;
  }
  if (typeof sortOrder !== "string") {
    return false;
  }
  if (!SORT_ORDER_IN_SEARCH.includes(sortOrder)) {
    return false;
  }
  if (typeof children2 !== "object") {
    return false;
  }
  if (!(children2 instanceof Array)) {
    return false;
  }
  for (const child of children2) {
    if (!isSearchResultItem(child)) {
      return false;
    }
  }
  if (typeof childrenEl !== "object") {
    return false;
  }
  if (!(childrenEl instanceof HTMLElement)) {
    return false;
  }
  return true;
}
function isSearchResultItem(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const { file, containerEl } = obj;
  if (!(file instanceof import_obsidian18.TFile)) {
    return false;
  }
  if (!(containerEl instanceof HTMLElement)) {
    return false;
  }
  return true;
}
function isSearchHeaderDom(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const { navButtonsEl } = obj;
  if (typeof navButtonsEl !== "object") {
    return false;
  }
  if (!(navButtonsEl instanceof HTMLDivElement)) {
    return false;
  }
  return true;
}

// src/utils/LinkedList.ts
var LinkedList = class {
  constructor(events, eventId) {
    this.unlinkedPool = new Map();
    this.events = events;
    this.eventId = eventId;
  }
  structure(cur, pre) {
    let linked = false;
    if (pre === void 0) {
      this.setRoot(cur);
      linked = true;
      this.signal();
    } else if (this.tail !== void 0 && pre === this.tail.entity) {
      this.link(cur);
      linked = true;
      this.unlinkedPool.delete(cur);
      this.signal();
    }
    if (linked) {
      if (!this.unlinkedPool.has(cur)) {
        return;
      }
      const next = this.unlinkedPool.get(cur);
      if (next === void 0) {
        return;
      }
      this.structure(next, cur);
    } else {
      if (pre) {
        this.unlinkedPool.set(pre, cur);
      }
    }
  }
  setRoot(entity) {
    const rootNode = {
      entity,
      pre: void 0,
      next: void 0
    };
    this.head = rootNode;
    this.tail = rootNode;
  }
  link(cur) {
    if (!this.tail) {
      return;
    }
    const currentTail = this.tail;
    currentTail.next = {
      entity: cur,
      pre: currentTail,
      next: void 0
    };
    this.tail = currentTail.next;
  }
  clean() {
    this.head = void 0;
    this.tail = void 0;
    this.unlinkedPool = new Map();
  }
  signal() {
    this.events.trigger(this.eventId);
  }
};

// src/interfaces/SearchComponentInterface.ts
var SearchComponentInterface = class extends import_obsidian19.Component {
  constructor(app, plugin, events) {
    super();
    this.observationConfig = {
      childList: true
    };
    this.onObservedCallback = (mutations, _observer) => __async(this, null, function* () {
      for (const mutation of mutations) {
        if (mutation.addedNodes.length === 0) {
          continue;
        }
        const pre = mutation.previousSibling;
        if (!(pre instanceof HTMLElement)) {
          continue;
        }
        for (const node of Array.from(mutation.addedNodes)) {
          if (!(node instanceof HTMLElement)) {
            continue;
          }
          const isSearchResultItem2 = node.tagName === "DIV" && node.hasClass("tree-item") && node.hasClass("search-result");
          if (!isSearchResultItem2) {
            continue;
          }
          if (!this.linkedList) {
            return;
          }
          this.linkedList.structure(node, this.isRootSearchResult(pre) ? void 0 : pre);
        }
      }
    });
    this.app = app;
    this.plugin = plugin;
    this.events = events;
    this.observer = new MutationObserver(this.onObservedCallback.bind(this));
  }
  onload() {
    this.app.workspace.onLayoutReady(() => {
      this.renewSortOrderInfo();
      this.registerDomEvent(document, "click", () => {
        this.renewSortOrderInfo(this.events);
      });
    });
  }
  onunload() {
    var _a, _b;
    (_a = this.sortOrderContainerEl) == null ? void 0 : _a.empty();
    (_b = this.sortOrderContainerEl) == null ? void 0 : _b.remove();
    this.observer.disconnect();
  }
  toggleMatchingCase() {
    const view = this.searchView;
    view == null ? void 0 : view.setMatchingCase(!view.matchingCase);
  }
  toggleExplainSearch() {
    const view = this.searchView;
    view == null ? void 0 : view.setExplainSearch(!view.explainSearch);
  }
  toggleCollapseAll() {
    const view = this.searchView;
    view == null ? void 0 : view.setCollapseAll(!view.dom.collapseAll);
  }
  toggleExtraContext() {
    const view = this.searchView;
    view == null ? void 0 : view.setExtraContext(!view.dom.extraContext);
  }
  setSortOrder(sortOrder) {
    const view = this.searchView;
    const originalOrder = view == null ? void 0 : view.dom.sortOrder;
    view == null ? void 0 : view.setSortOrder(sortOrder);
    return sortOrder !== originalOrder;
  }
  focusOn(pos) {
    var _a;
    this.unfocus();
    const item = this.getResultItemAt(pos);
    if (!item) {
      return;
    }
    item.containerEl.addClass("core-search-assistant_search-result-items-focus");
    item.containerEl.scrollIntoView(((_a = this.plugin.settings) == null ? void 0 : _a.keepSelectedItemsCentered) ? { block: "center" } : { block: "nearest" });
  }
  unfocus() {
    const items = this.resultItems;
    items.forEach((item) => {
      item.containerEl.removeClass("core-search-assistant_search-result-items-focus");
    });
  }
  open(pos, direction) {
    return __async(this, null, function* () {
      const item = this.getResultItemAt(pos);
      if (!item) {
        return;
      }
      const { file } = item;
      const leaf = direction === void 0 ? this.app.workspace.getMostRecentLeaf() : this.app.workspace.splitActiveLeaf(direction);
      yield leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf, true, true);
    });
  }
  renewSortOrderInfo(events) {
    if (!this.sortOrderContainerEl) {
      this.createSortOrderEls();
    }
    const view = this.searchView;
    if (!view) {
      return;
    }
    const sortOrder = view.dom.sortOrder;
    if (!this.sortOrderContentEl) {
      return;
    }
    const originalContent = this.sortOrderContentEl.textContent;
    this.sortOrderContentEl.textContent = searchOptions[sortOrder].description;
    if (events !== void 0 && originalContent !== this.sortOrderContentEl.textContent) {
      events.trigger(EVENT_SORT_ORDER_CHANGED);
    }
  }
  count() {
    var _a;
    const results = (_a = this.searchView) == null ? void 0 : _a.dom.children;
    if (!results) {
      return 0;
    }
    return results.length;
  }
  get resultItems() {
    var _a, _b;
    return (_b = (_a = this.searchView) == null ? void 0 : _a.dom.children) != null ? _b : [];
  }
  getResultItemAt(pos) {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.dom.children[pos];
  }
  get searchInputEl() {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.searchComponent.inputEl;
  }
  startWatching(events) {
    var _a;
    this.linkedList = new LinkedList(events, EVENT_SEARCH_RESULT_ITEM_DETECTED);
    const childrenContainerEl = (_a = this.searchView) == null ? void 0 : _a.dom.childrenEl;
    if (!(childrenContainerEl instanceof HTMLElement)) {
      throw "[ERROR in Core Search Assistant] failed to SearchComponentInterface#startWatching: childrenContainerEl is not an instance of HTMLElement";
    }
    this.observer.observe(childrenContainerEl, this.observationConfig);
  }
  stopWatching() {
    this.observer.disconnect();
  }
  collapseOppositeSidedock() {
    const sideDock = this.oppositeSidedock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to collapseOppositeSidedock: failed to fetch the opposite sidedock";
    }
    sideDock.collapse();
  }
  expandOppositeSidedock() {
    const sideDock = this.oppositeSidedock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to expandOppositeSidedock: failed to fetch the opposite sidedock";
    }
    sideDock.expand();
  }
  collapseSidedock() {
    const sideDock = this.sideDock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to collapseSidedock: failed to fetch the sidedock";
    }
    sideDock.collapse();
  }
  get sideDock() {
    const leaf = this.searchLeaf;
    if (leaf === void 0) {
      return void 0;
    }
    const parent = leaf.getRoot();
    if (parent instanceof import_obsidian19.WorkspaceSidedock) {
      return parent;
    } else {
      return void 0;
    }
  }
  get oppositeSidedock() {
    const leaf = this.searchLeaf;
    if (leaf === void 0) {
      return void 0;
    }
    const parent = leaf.getRoot();
    if (parent === this.app.workspace.leftSplit) {
      const opposite = this.app.workspace.rightSplit;
      return opposite instanceof import_obsidian19.WorkspaceSidedock ? opposite : void 0;
    } else if (parent === this.app.workspace.rightSplit) {
      const opposite = this.app.workspace.leftSplit;
      return opposite instanceof import_obsidian19.WorkspaceSidedock ? opposite : void 0;
    } else {
      return void 0;
    }
  }
  createSortOrderEls() {
    this.sortOrderContainerEl = createEl("div", {
      cls: "search-info-container"
    });
    this.sortOrderContentEl = this.sortOrderContainerEl.createEl("div");
    const view = this.searchView;
    if (!view) {
      return void 0;
    }
    this.sortOrderContainerEl.insertAfter(view.searchInfoEl);
  }
  get matchingCaseButtonEl() {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.matchingCaseButtonEl;
  }
  get tabHeaderEl() {
    var _a;
    return (_a = this.searchLeaf) == null ? void 0 : _a.tabHeaderEl;
  }
  isBuiltInElementToOpenFile(el) {
    const isFileNameContainerEl = el.tagName === "DIV" && el.hasClass("tree-item-inner");
    const isMatchCountContainerEl = el.tagName === "DIV" && el.hasClass("tree-item-flair-outer");
    const isMatchContainerEl = el.tagName === "DIV" && el.hasClass("search-result-file-match");
    if (isFileNameContainerEl || isMatchContainerEl || isMatchCountContainerEl) {
      return true;
    }
    const parentEl = el.parentElement;
    if (parentEl === null) {
      return false;
    } else {
      return this.isBuiltInElementToOpenFile(parentEl);
    }
  }
  isShowMoreContextButton(el) {
    return el.tagName === "DIV" && el.hasClass("search-result-hover-button");
  }
  get searchView() {
    const leaf = this.searchLeaf;
    if (!leaf) {
      return void 0;
    }
    const view = leaf.view;
    return isSearchView(view) ? view : void 0;
  }
  get searchLeaf() {
    return this.app.workspace.getLeavesOfType("search")[0];
  }
  isRootSearchResult(el) {
    return el.tagName === "DIV" && !el.hasClass("tree-item") && !el.hasClass("search-result");
  }
};

// src/main.ts
var import_obsidian20 = __toModule(require("obsidian"));
var CoreSearchAssistantPlugin2 = class extends import_obsidian20.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.events = new CoreSearchAssistantEvents();
      this.searchInterface = this.addChild(new SearchComponentInterface(this.app, this, this.events));
      this.controller = this.addChild(new Controller(this.app, this, this.events, this.searchInterface));
      this.watchLayoutChange();
      this.addSettingTab(new CoreSearchAssistantSettingTab(this.app, this));
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = deepMerge(DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  renewController() {
    if (this.controller) {
      this.removeChild(this.controller);
    }
    if (this.events === void 0) {
      throw "[ERROR in Core Search Interface] failed to renewController: plugin.events = undefined";
    }
    if (this.searchInterface === void 0) {
      throw "[ERROR in Core Search Interface] failed to renewController: plugin.searchInterface = undefined";
    }
    this.controller = this.addChild(new Controller(this.app, this, this.events, this.searchInterface));
  }
  watchLayoutChange() {
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.on("layout-change", () => __async(this, null, function* () {
        var _a;
        if (yield (_a = this.controller) == null ? void 0 : _a.layoutChanged()) {
          this.renewController();
        }
      }));
    });
  }
};
